import asyncio  # Импортируем библиотеку asyncio для асинхронного программирования
import time     # Импортируем модуль time для возможного использования функций задержки времени

# Асинхронная функция загрузки данных
async def fetch_data():      
    print("Starts downloading data")      # Печатаем сообщение начала загрузки данных
    await asyncio.sleep(5)                # Эмулируем задержку в выполнении операции загрузки (ожидаем 5 секунд)
    print("The data is uploaded!")        # Сообщение окончания загрузки данных
    return "result"                      # Возвращаем строку 'result'

# Асинхронная функция обработки данных
async def convert_data():                
    print("Starting to process the data: ")  # Сообщение начала обработки данных
    await asyncio.sleep(2)                     # Эмулируем задержку в обработке данных (ожидаем 2 секунды)
    print("The data has been processed: ")    # Сообщение успешного завершения обработки данных

# Получаем объект event loop (цикл событий), управляющий выполнением асинхронных задач
ioloop = asyncio.get_event_loop()

# Создаем список задач, каждая задача представляет собой запуск соответствующей асинхронной функции
tasks = [
    ioloop.create_task(fetch_data()),       # Создаем задачу на загрузку данных
    ioloop.create_task(convert_data())     # Создаем задачу на обработку данных
]

# Готовим ожидание выполнения всех созданных задач одновременно
task_for_wait = asyncio.wait(tasks)

# Блокируем выполнение программы до тех пор, пока все указанные задачи не будут выполнены
ioloop.run_until_complete(task_for_wait)

# Закрываем цикл событий, освобождая ресурсы
ioloop.close()
